\documentclass[sigconf,9pt]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{listings}
\lstset{
  basicstyle=\scriptsize,
}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning,fit,calc,decorations.markings}
\usepackage{pgfplots}
\pgfplotsset{compat=newest} % Allows to place the legend below plot
\usepgfplotslibrary{units} % Allows to enter the units nicely
\usepackage{url}

\newcommand{\elq}{ELQ}
\newcommand{\code}[1]{\texttt{#1}}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
\acmDOI{10.475/123_4}

% ISBN
\acmISBN{123-4567-24-567/08/06}

%Conference
\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El
  Paso, Texas USA}
\acmYear{1997}
\copyrightyear{2016}

\acmPrice{15.00}


\begin{document}
\title{SIG Proceedings Paper in LaTeX Format}
\titlenote{Produces the permission block, and
  copyright information}
\subtitle{Extended Abstract}
\subtitlenote{The full version of the author's guide is available as
  \texttt{acmart.pdf} document}


\author{Ben Trovato}
\authornote{Dr.~Trovato insisted his name be first.}
\orcid{1234-5678-9012}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \postcode{43017-6221}
}
\email{trovato@corporation.com}

\author{G.K.M. Tobin}
\authornote{The secretary disavows any knowledge of this author's actions.}
\affiliation{%
  \institution{Institute for Clarity in Documentation}
  \streetaddress{P.O. Box 1212}
  \city{Dublin}
  \state{Ohio}
  \postcode{43017-6221}
}
\email{webmaster@marysville-ohio.com}

\author{Lars Th{\o}rv{\"a}ld}
\authornote{This author is the
  one who did all the really hard work.}
\affiliation{%
  \institution{The Th{\o}rv{\"a}ld Group}
  \streetaddress{1 Th{\o}rv{\"a}ld Circle}
  \city{Hekla}
  \country{Iceland}}
\email{larst@affiliation.org}

\author{Lawrence P. Leipuner}
\affiliation{
  \institution{Brookhaven Laboratories}
  \streetaddress{P.O. Box 5000}}
\email{lleipuner@researchlabs.org}

\author{Sean Fogarty}
\affiliation{%
  \institution{NASA Ames Research Center}
  \city{Moffett Field}
  \state{California}
  \postcode{94035}}
\email{fogartys@amesres.org}

\author{Charles Palmer}
\affiliation{%
  \institution{Palmer Research Laboratories}
  \streetaddress{8600 Datapoint Drive}
  \city{San Antonio}
  \state{Texas}
  \postcode{78229}}
\email{cpalmer@prl.com}

\author{John Smith}
\affiliation{\institution{The Th{\o}rv{\"a}ld Group}}
\email{jsmith@affiliation.org}

\author{Julius P.~Kumquat}
\affiliation{\institution{The Kumquat Consortium}}
\email{jpkumquat@consortium.net}

% The default list of authors is too long for headers}
\renewcommand{\shortauthors}{B. Trovato et al.}


\begin{abstract}
    It is challenging to develop large, responsive applications with CSS
    media queries. Responsive elements realized using CSS media queries
    always depend on the global context, thereby precluding
    modularity. The lack of true modularity makes certain requirement
    changes either impossible or expensive to realize.

    In this paper we extend Responsive Web Design (RWD) to also include
    {\em responsive modules}.  We present \elq{}, a novel implementation
    of so-called \emph{element queries} which generalize CSS media
    queries.  Importantly, our design conforms to existing web
    specifications, enabling adoption on a large scale.  Experimental
    results show speed-ups of the core algorithms of up to 37x compared
    to previous approaches.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>10010520.10010553.10010562</concept_id>
  <concept_desc>Computer systems organization~Embedded systems</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010575.10010755</concept_id>
  <concept_desc>Computer systems organization~Redundancy</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>10010520.10010553.10010554</concept_id>
  <concept_desc>Computer systems organization~Robotics</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>10003033.10003083.10003095</concept_id>
  <concept_desc>Networks~Network reliability</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Computer systems organization~Embedded systems}
\ccsdesc[300]{Computer systems organization~Redundancy}
\ccsdesc{Computer systems organization~Robotics}
\ccsdesc[100]{Networks~Network reliability}

% We no longer use \terms command
%\terms{Theory}

\keywords{Responsive web design, Element queries, CSS, Modularity}


\maketitle

\section{Introduction}
  Responsive Web Design (RWD) is an approach to make an application respond to the viewport size and other device characteristics.
  This is currently achieved using CSS media queries which are designed to conditionally design content by the media, such as using serif fonts when printed and sans-serif when viewed on a screen \cite{w3c_css_mq}.
  In order to reduce complexity and enable reusability, applications are typically composed of modules, i.e., interchangeable and independent parts that have a single and well-defined responsibility \cite{parnas1972criteria}.
  In order for a module to be reusable it must not assume in which context it is being used.

  The problem is that there is no way to make a module responsive without making it context-aware, due to the fact that media queries can only target the viewport; this means that responsive modules can only respond to changes of the (global) viewport.
  Thus, a responsive module using media queries is layout dependent and has both reduced functionality and limited reusability~\cite{elq-thesis}.
  In a world where no better solution than media queries exists for RWD, changing the layout of a responsive application becomes a cumbersome task since it may require many responsive modules to be updated.

  \paragraph{The Problem Exemplified.}
    Imagine a company working on a big application that uses media queries for responsiveness (i.e., each responsive module assumes to have a specific percentage of the viewport size).
    The ability to change is desired by both developers and stakeholders, but is limited by this responsive approach.
    The requirement of changing a menu from being a horizontal menu at the top to being a vertical menu on the side implies that all responsive modules break, since the assumed proportionality of each module is changed.
    Even worse, if the menu is also supposed to hide on user input, the responsiveness of the modules break, since the layout changes dynamically.
    The latter requirement is impossible to satisfy in a modular way without element queries.

  \paragraph{Requirements.}\label{sec:reqs}
    The desired behavior of a responsive module is having its inner
    design respond to the size of its \emph{container} instead of the
    viewport, to make it independent of its layout context.  The W3C
    has discussed such a feature under the name of \emph{element
      queries} given its analogy to media queries~\cite{w3c_eq_mail}.
    We have identified the following requirements: a solution must (a)
    provide the possibility for an element to automatically respond to
    changes of its parent's properties; (b) conform to the syntax of
    HTML, CSS, and JavaScript to retain the compatibility of tools,
    libraries and existing projects; (c) have adequate performance;
    (d) enable developers to write encapsulated style rules, so that
    responsive modules may be arbitrarily composed without any
    conflicting style rules.

  \paragraph{Contributions.}
    This paper makes the following contributions:
    \begin{itemize}
      \item A new design for element queries that enables responsive modules while conforming to the syntax of HTML, CSS, and JavaScript.
      \item
        Our approach is the first to enable nested elements that are responsive in a modular way, i.e., modules fully encapsulate any styling required for RWD.
        As a side effect, responsive modules may also be arbitrarily styled with CSS independent of their context.
      \item
        A new implementation\footnote{ELQ, an open-source library (MIT license): \url{https://github.com/elqteam/elq}} that offers substantially higher performance than previous approaches.
      \item
        A run-time cycle detection system that detects and breaks cycles stemming from cyclic rules due to unrestricted usage of element queries~\cite{elq-thesis}.
    \end{itemize}

\section{Overview of \elq{}}\label{sec:elq}\label{sec:elq-api}
  An \emph{element breakpoint} is defined as a point of an element
  property range which can be used to define conditional behavior,
  similar to breakpoints of media queries.  For example, if an element
  that is 300 pixels wide has two width breakpoints of 200 and 400
  pixels the {\em element breakpoint states} are ``wider than 200
  pixels'' and ``narrower than 400 pixels''.

  The main idea is to define element breakpoints of interest so that children can be adapted to the different breakpoint states.
  As a library, \elq{} provides a JavaScript API to registering element breakpoints, and detecting breakpoint state changes.
  \elq{} then observes the elements, in order to automatically let the system know when a breakpoint has changed state.
  The JavaScript API is extensible through plugins.
  Mainly, plugins provide alternative behaviors and API's for breakpoint registration and action on breakpoint state changes.
  In our companion technical report~\cite{WienerEH15} we show an example plugin that provides a grid API similar to the CSS Bootstrap framework.

  \paragraph{Default plugins.}
  The default plugins of \elq{} let users define element breakpoints by HTML attributes in addition to the JavaScript API:
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={}]]
    <div class="foo" data-elq-breakpoints-widths="300 500">
      <p>When in doubt, mumble.</p>
    </div>
  \end{lstlisting}
  The plugins also update element classes to reflect the current breakpoint states, which may be targeted in CSS selectors.
  For instance, if the element is 400 pixels wide, the element has the two classes \code{elq-min-width-300px} and \code{elq-max-width-500px}.
  For each breakpoint only the min/max part changes, to mimic CSS media queries.
  This is how the classes may be used in CSS to conditionally style the children:
  \begin{lstlisting}[gobble=4]
    .foo.elq-max-width-300px                     { background-color: blue; }
    .foo.elq-min-width-300px.elq-max-width-500px { background-color: green; }
    .foo.elq-min-width-500px p                   { color: white; }
  \end{lstlisting}
  This is however not sufficient for nestable modules since there is no way to limit the CSS matching search of the selectors.
  The last style rule specifies that all paragraph elements should have white text if \emph{any} \code{.foo} ancestor breakpoints element is wider than 500 pixels.
  Since the ancestor selector may match elements outside of the module, such selectors are dangerous to use in the context of responsive modules.
  The problem may be somewhat reduced by more specific selectors and such, but it cannot be fully solved for arbitrary styling \cite{elq-thesis}.

  To enable nestable modules, the default plugins let us define elements to ``mirror'' the breakpoints classes of the nearest ancestor breakpoints element (the target of the mirror element).
  This means that the mirror element always reflects the element breakpoint states of the target.
  The following is an example of using mirroring to have a \code{.foo} module contain another \code{.foo} module:
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={}]]
    <div class="foo" data-elq-breakpoints-widths="300 500">
      <div class="foo" data-elq-breakpoints-widths="300 500">
        <p data-elq-mirror>...</p>
      </div>
      <p data-elq-mirror>...</p>
    </div>
  \end{lstlisting}
  The paragraph elements are told to mirror the nearest breakpoints element by the \code{data-elq-mirror} annotation.
  Then, the conditional style of pragraph elements may be written as a combinatory selector:
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={code:elq-mirror-example-css}]]
    .foo p.elq-min-width-500px { color: white; }
  \end{lstlisting}
  Since the breakpoint state class is now combined with the paragraph, the conditional style will only be applied in relation to the actual desired breakpoints element parent.

  \section{Empirical evaluation}\label{sec:eval}
    Only the performance of the element resize detection system has
    been evaluated.  This is due to the fact that detecting element
    resize events entails all the significant performance penalties of
    \elq{}.  Fortunately, element resize detection is the common
    denominator of all automatic libraries and the results of this
    system can be compared faithfully.  Measurements and graphs show
    evaluations performed in Chrome version 42 unless stated
    otherwise.  Previous implementations use one of two
    approaches~\cite{backalley}: (a) {\em object-based} resize
    detection, which uses \verb|object| elements, and (b) {\em
      scroll-based} resize detection, which uses overflowing elements.
    The approach of \elq{} extends the scroll-based approach with
    batch processing to increase performance~\cite{WienerEH15}.

    %\subsection{Performance}\label{sec:eval-perf}
      % \begin{wrapfigure}{r}{0.5\textwidth}
      \begin{center}
        \begin{tikzpicture}
          \tiny
              \begin{axis}[
                  width=0.5\textwidth, % Scale the plot to \linewidth
                  grid=major, % Display a grid
                  grid style={dashed,gray!30}, % Set the style
                  xlabel=Number of elements, % Set the labels
                  ylabel=Injection time,
                  y unit=s, % Set the respective units
                  legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
                ]
                \addplot+[red, mark options={red}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-object-original.csv};
                \addplot+[orange, mark options={orange}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-original.csv};
                \addplot+[blue, mark options={blue}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-elq.csv};
                %\addplot[dashed,red,domain=1:1500,samples=100] {5.567042796*10^(-6)*x^2 + 4.680174396*10^(-3)*x + 6.495754669*10^(-3)};
                %\addplot[dashed,orange,domain=1:1500,samples=100] {4.533208873*10^(-6)*x^2 + 6.320377596*10^(-4)*x + 2.289566005*10^(-2)};
                %\addplot[dashed,blue,domain=1:1500,samples=100] {4.071740702*10^(-8)*x^2 + 1.823749404*10^(-4)*x + 1.527042267*10^(-2)};
                \addlegendentry{Object-based approach}
                \addlegendentry{Scroll-based approach}
                \addlegendentry{ELQ scroll-based approach}
              \end{axis}
            \end{tikzpicture}
      \end{center}
      %\caption{Birds}
      % \end{wrapfigure}

    \noindent
    The plot compares the start-up performance
    of \elq{}'s scroll-based approach with the other two approaches.
    \elq{} achieves a 37-fold speedup compared to the object-based
    approach and a 17-fold speedup compared to the scroll-based
    approach when preparing 700 elements for resize detection.  It
    also performs well when detecting resize events, which it does
    with a delay of 25 ms for 100 elements.

    \paragraph{Modularizing Bootstrap.}
    We have adapted the popular Bootstrap~\cite{bootstrap} framework
    to use element queries instead of media queries, to enable its use
    by responsive modules. By using CSS preprocessors to make the
    syntax of \elq{} element queries similar to media queries, only
    0.6\% of LOC changes were required.
    Our companion technical report~\cite{WienerEH15} provides more details,
    including code examples.
    In summary we have shown that
    it is easy to adapt existing responsive code to use \elq{}'s
    element queries instead of media queries.

    \paragraph{Industrial use of \elq{}.}
    We have also been gathering experience with the application of
    \elq{} in large financial applications developed at EVRY.
    Our practical experience shows that complex applications
    require a variety of features to be supported by element queries.
    Such features can be provided effectively by \elq{} plugins.
    We have noticed that in most of our responsive modules, it has been beneficial for us to use the JavaScript API
    to conditionally render whole chunks of HTML instead of only changing the style using CSS.
    Two teams at EVRY have independently come to this same conclusion, and have developed plugins to ease the usage with the different frameworks that the teams are using (Angular and React).

\section{Related Work}\label{sec:related}

  \paragraph{Syntax extensions.}
  The libraries~\cite{eq_imp_magichtml,eq_imp_eqcss,eq_imp_prollyfill-min-width,eq_imp_localised-css,eq_imp_gss} have in common that they require developers to write custom CSS, unlike \elq{}.
  Since they do not conform to the CSS standard, new features are supported through custom CSS parsed using JavaScript.
  As shown by \cite{eq_imp_eqcss,eq_imp_gss} quite advanced features can be implemented this way.
  Additionally, adding new CSS features implies that it is possible to implement a solution to element queries that does not require any changes to the HTML, which may be preferable since all styling then can be written in CSS.
  However, there are numerous drawbacks with libraries that require custom CSS.
  Extending the CSS syntax violates the requirement of compatability and also introduces a compilation step which decreases the performance \cite{elq-thesis}.

  \paragraph{Resize detection.}
  The libraries \cite{eq_imp_eqcss,eq_imp_breakpointsjs,eq_imp_mediaclass,eq_imp_elementquery,eq_imp_responsive-elements,eq_imp_sickles,eq_imp_responsive-elements-2,eq_imp_breaks2000,eq_imp_eqjs} simply observe the viewport resize event, which may be enough for static pages, but not enough to satisfy the requirements of reusable responsive modules \cite{elq-thesis}.
  Approach \cite{eq_imp_classquery} does not detect resize events at all.
  Like \elq{}, \cite{eq_imp_localised-css,eq_imp_selector_queries,eq_imp_prollyfill-min-width,eq_imp_gss,eq_imp_element-queries,eq_imp_css-element-queries} observe \emph{elements} for resize events.
  The libraries \cite{eq_imp_localised-css,eq_imp_selector_queries} use polling while \elq{} and \cite{eq_imp_prollyfill-min-width,eq_imp_gss,eq_imp_element-queries,eq_imp_css-element-queries} use different injection approaches.
  As shown in Section~\ref{sec:eval}, the injection approaches used by related libraries have significantly less performance than the element resizing detection system used in \elq{}.

  \paragraph{Constraint-based CSS.}˘
  CCSS~\cite{badros1999constraint} proposes a more general and flexible alternative to CSS.
  The idea of CCSS is to layout documents based on constraints.
  The Grid Style Sheets library \cite{eq_imp_gss} builds upon the ideas of CCSS.
  While not directly offering element queries, the library enables the possibility to conditionally style elements by element criteria and thus makes it a good candidate to solve the problem of responsive modules.
  However, the library has two major issues: performance and browser compatibility \cite{gss_issue}.
  In contrast, \elq{} only considers element queries, but without browser compatibility limitations and with higher performance.

  \section{Conclusion}\label{sec:conclusion}
    %Responsive Web Design (RWD) enables web applications to adapt to the characteristics of different devices, which is achieved using CSS media queries.
    %However, using media queries it is impossible to create responsive applications in a modular way, because responsive elements then always depend on the global context.

    This paper extends Responsive Web Design (RWD) with {\em responsive
      modules} through element queries.  Our approach is the first to
    enable nested elements that are responsive in a modular way, i.e.,
    modules fully encapsulate any styling required for RWD.  Our
    implementation, \elq{}, is fully compatible with existing web
    standards and technologies. The element resize detection of \elq{}
    performs up to 37x better than previous algorithms.  We present a
    case study which shows that changing only about 0.6\% of the LOC is
    sufficient to enable the use of the popular Bootstrap framework in
    responsive modules.  We also report on first commercial usage of
    \elq{}.

\bibliographystyle{ACM-Reference-Format}

% TODO: Change 2015 to something better in the bib file!
\bibliography{elq}  % elq.bib is the name of the Bibliography in this case

\end{document}
