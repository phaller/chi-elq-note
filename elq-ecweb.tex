% This is lnbip.tex the demonstration file of the LaTeX macro package for
% Lecture Notes in Business Information Processing from Springer-Verlag.
% It serves as a template for authors as well.
% version 1.0 for LaTeX2e
%
\documentclass[lnbip]{svmultln}
%
\usepackage{makeidx}  % allows for indexgeneration
% \makeindex          % be prepared for an author index
%

\usepackage{amssymb}
\setcounter{tocdepth}{3}
\usepackage{graphicx}
\usepackage{listings}
\lstset{
  basicstyle=\scriptsize,
}
\usepackage{tikz}
\usetikzlibrary{arrows,positioning,fit,calc,decorations.markings}
\usepackage{pgfplots}
\pgfplotsset{compat=newest} % Allows to place the legend below plot
\usepgfplotslibrary{units} % Allows to enter the units nicely
\usepackage{multirow}

\usepackage{wrapfig}

\usepackage{url}
\urldef{\mailsa}\path|lucas.wiener@evry.com, tomase@kth.se, phaller@kth.se|

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\elq}{ELQ}
\newcommand{\comment}[1]{}

\begin{document}
%
\mainmatter              % start of the contribution
%
\title{Modular Responsive Web Design using\\ Element Queries}
%
\titlerunning{Modular Responsive Web Design using Element Queries}  % abbreviated title (for running head)
%                                     also used for the TOC unless
%                                     \toctitle is used
%
\author{Lucas Wiener\inst{1}%
\and Tomas Ekholm\inst{1,2}\and Philipp Haller\inst{2}}
%
\authorrunning{Lucas Wiener et al.}   % abbreviated author list (for running head)
%
%%%% list of authors for the TOC (use if author list has to be modified)
%\tocauthor{Ivar Ekeland, Roger Temam, Jeffrey Dean, David Grove,
%Craig Chambers, Kim B. Bruce, Elisa Bertino}
%
\institute{EVRY AB, Sweden
\and KTH Royal Institute of Technology, Sweden
\mailsa\\}

\maketitle              % typeset the title of the contribution
% \index{Ekeland, Ivar} % entries for the author index
% \index{Temam, Roger}  % of the whole volume
% \index{Dean, Jeffrey}

\comment{
  CSS media queries preclude modularity, because
  always depend on the global context.

  to make the presentation layer
  responsive precludes modularity, because}


\begin{abstract}        % give a summary of your paper
  It is challenging to develop large, responsive applications with CSS
  media queries. Responsive elements realized using CSS media queries
  always depend on the global context, thereby precluding
  modularity. The lack of true modularity makes certain requirement
  changes either impossible or expensive to realize.

  In this paper we extend Responsive Web Design (RWD) to also include
  {\em responsive modules}.  We present \elq{}, a novel implementation
  of so-called \emph{element queries} which generalize CSS media
  queries.  Importantly, our design conforms to existing web
  specifications, enabling adoption on a large scale.  Experimental
  results show speed-ups of the core algorithms of up to 37x compared
  to previous approaches.

%                         please supply keywords within your abstract
\keywords{Responsive web design, Element queries, CSS, Modularity}
\end{abstract}
%
\section{Introduction}

  Responsive Web Design (RWD) is an approach to make an application respond to the viewport size and other device characteristics.
  This is currently achieved using CSS media queries which are designed to conditionally design content by the media, such as using serif fonts when printed and sans-serif when viewed on a screen \cite{w3c_css_mq}.
  In order to reduce complexity and enable reusability, applications are typically composed of modules, i.e., interchangeable and independent parts that have a single and well-defined responsibility \cite{parnas1972criteria}.
  In order for a module to be reusable it must not assume in which context it is being used.

  The problem is that there is no way to make a module responsive without making it context-aware, due to the fact that media queries can only target the viewport; this means that responsive modules can only respond to changes of the (global) viewport.
  Thus, a responsive module using media queries is layout dependent and has both reduced functionality and limited reusability~\cite{elq-thesis}.
  In a world where no better solution than media queries exists for RWD, changing the layout of a responsive application becomes a cumbersome task since it may require many responsive modules to be updated.

  \paragraph{The Problem Exemplified.}
    Imagine a company working on a big application that uses media queries for responsiveness (i.e., each responsive module assumes to have a specific percentage of the viewport size).
    The ability to change is desired by both developers and stakeholders, but is limited by this responsive approach.
    The requirement of changing a menu from being a horizontal menu at the top to being a vertical menu on the side implies that all responsive modules break, since the assumed proportionality of each module is changed.
    Even worse, if the menu is also supposed to hide on user input, the responsiveness of the modules break, since the layout changes dynamically.
    The latter requirement is impossible to satisfy in a modular way without element queries.

  \paragraph{Requirements.}\label{sec:reqs}
    The desired behavior of a responsive module is having its inner
    design respond to the size of its \emph{container} instead of the
    viewport, to make it independent of its layout context.  The W3C
    has discussed such a feature under the name of \emph{element
      queries} given its analogy to media queries~\cite{w3c_eq_mail}.
    We have identified the following requirements: a solution must (a)
    provide the possibility for an element to automatically respond to
    changes of its parent's properties; (b) conform to the syntax of
    HTML, CSS, and JavaScript to retain the compatibility of tools,
    libraries and existing projects; (c) have adequate performance;
    (d) enable developers to write encapsulated style rules, so that
    responsive modules may be arbitrarily composed without any
    conflicting style rules.

  \paragraph{Contributions.}
    This paper makes the following contributions:
    \begin{itemize}
      \item A new design for element queries that enables responsive modules while conforming to the syntax of HTML, CSS, and JavaScript.
      \item
        Our approach is the first to enable nested elements that are responsive in a modular way, i.e., modules fully encapsulate any styling required for RWD.
        As a side effect, responsive modules may also be arbitrarily styled with CSS independent of their context.
      \item
        A new implementation\footnote{ELQ, an open-source library (MIT license): \url{https://github.com/elqteam/elq}} that offers substantially higher performance than previous approaches.
      \item
        A run-time cycle detection system that detects and breaks cycles stemming from cyclic rules due to unrestricted usage of element queries~\cite{elq-thesis}.
    \end{itemize}

  \comment{
  \noindent
  The rest of the paper is organized as follows.
  Section~\ref{sec:elq} introduces \elq{} and its API from a user's perspective.
  Section~\ref{sec:imp} provides an overview of the implementation of \elq{}'s element resize detection system.
  In Section~\ref{sec:eval} we evaluate the performance of \elq{} and report on case studies.
  Section~\ref{sec:discussion} discusses limitations of \elq{} and related libraries, as well as the current state of standardization of element queries.
  Section~\ref{sec:related} relates \elq{} to prior work, and Section~\ref{sec:conclusion} concludes.}

\section{Overview of \elq{}}\label{sec:elq}\label{sec:elq-api}
% TODO: Write about px, em, rem somewhere in this section.
  \comment{
  Media queries and element queries are similar in the sense that they both enable developers to define conditional designs that are applied by specified criteria.
  The main difference is the type of criteria that can be used.
  With media queries critera of the device, document, and media are used, while element criteria are used with element queries.
  It can somewhat simplified be described as that media queries target the document root and up such as viewport, browser, device, and input mechanisms.
  Element queries target the document root and down, i.e., elements of the document.

  \elq{} is designed to be plugin-based for increased flexibility and extensibility.
  By providing a good library foundation and plugins it is up to developers to choose the right plugins for each project.
  In addition, by letting the plugins satisfy the requirements it is easy to extend the library with new plugins when new requirements arise.}

  An \emph{element breakpoint} is defined as a point of an element
  property range which can be used to define conditional behavior,
  similar to breakpoints of media queries.  For example, if an element
  that is 300 pixels wide has two width breakpoints of 200 and 400
  pixels the {\em element breakpoint states} are ``wider than 200
  pixels'' and ``narrower than 400 pixels''.

  \comment{When the breakpoint states of an element changes, \elq{} performs cycle detection in order to detect and handle possible style cycles.
  If a cycle is detected, the new element breakpoint states are not applied in order to avoid an infinite loop of layouts.
  The cycle detection system is implemented as a conservative algorithm, and may in some cases detect false positives.}

  The main idea is to define element breakpoints of interest so that children can be adapted to the different breakpoint states.
  As a library, \elq{} provides a JavaScript API to registering element breakpoints, and detecting breakpoint state changes.
  \elq{} then observes the elements, in order to automatically let the system know when a breakpoint has changed state.
  The JavaScript API is extensible through plugins.
  Mainly, plugins provide alternative behaviors and API's for breakpoint registration and action on breakpoint state changes.
  In our companion technical report~\cite{WienerEH15} we show an example plugin that provides a grid API similar to the CSS Bootstrap framework.

  \paragraph{Default plugins.}
  The default plugins of \elq{} let users define element breakpoints by HTML attributes in addition to the JavaScript API:
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={}]]
    <div class="foo" data-elq-breakpoints-widths="300 500">
      <p>When in doubt, mumble.</p>
    </div>
  \end{lstlisting}
  The plugins also update element classes to reflect the current breakpoint states, which may be targeted in CSS selectors.
  For instance, if the element is 400 pixels wide, the element has the two classes \code{elq-min-width-300px} and \code{elq-max-width-500px}.
  For each breakpoint only the min/max part changes, to mimic CSS media queries.
  This is how the classes may be used in CSS to conditionally style the children:
  \begin{lstlisting}[gobble=4]
    .foo.elq-max-width-300px                     { background-color: blue; }
    .foo.elq-min-width-300px.elq-max-width-500px { background-color: green; }
    .foo.elq-min-width-500px p                   { color: white; }
  \end{lstlisting}
  This is however not sufficient for nestable modules since there is no way to limit the CSS matching search of the selectors.
  The last style rule specifies that all paragraph elements should have white text if \emph{any} \code{.foo} ancestor breakpoints element is wider than 500 pixels.
  Since the ancestor selector may match elements outside of the module, such selectors are dangerous to use in the context of responsive modules.
  The problem may be somewhat reduced by more specific selectors and such, but it cannot be fully solved for arbitrary styling \cite{elq-thesis}.

  To enable nestable modules, the default plugins let us define elements to ``mirror'' the breakpoints classes of the nearest ancestor breakpoints element (the target of the mirror element).
  This means that the mirror element always reflects the element breakpoint states of the target.
  The following is an example of using mirroring to have a \code{.foo} module contain another \code{.foo} module:
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={}]]
    <div class="foo" data-elq-breakpoints-widths="300 500">
      <div class="foo" data-elq-breakpoints-widths="300 500">
        <p data-elq-mirror>...</p>
      </div>
      <p data-elq-mirror>...</p>
    </div>
  \end{lstlisting}
  The paragraph elements are told to mirror the nearest breakpoints element by the \code{data-elq-mirror} annotation.
  Then, the conditional style of pragraph elements may be written as a combinatory selector:
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={code:elq-mirror-example-css}]]
    .foo p.elq-min-width-500px { color: white; }
  \end{lstlisting}
  Since the breakpoint state class is now combined with the paragraph, the conditional style will only be applied in relation to the actual desired breakpoints element parent.

  \section{Empirical evaluation}\label{sec:eval}
    Only the performance of the element resize detection system has
    been evaluated.  This is due to the fact that detecting element
    resize events entails all the significant performance penalties of
    \elq{}.  Fortunately, element resize detection is the common
    denominator of all automatic libraries and the results of this
    system can be compared faithfully.  Measurements and graphs show
    evaluations performed in Chrome version 42 unless stated
    otherwise.  Previous implementations use one of two
    approaches~\cite{backalley}: (a) {\em object-based} resize
    detection, which uses \verb|object| elements, and (b) {\em
      scroll-based} resize detection, which uses overflowing elements.
    The approach of \elq{} extends the scroll-based approach with
    batch processing to increase performance~\cite{WienerEH15}.

    %\subsection{Performance}\label{sec:eval-perf}
      % \begin{wrapfigure}{r}{0.5\textwidth}
      \begin{center}
        \begin{tikzpicture}
          \tiny
              \begin{axis}[
                  width=0.5\textwidth, % Scale the plot to \linewidth
                  grid=major, % Display a grid
                  grid style={dashed,gray!30}, % Set the style
                  xlabel=Number of elements, % Set the labels
                  ylabel=Injection time,
                  y unit=s, % Set the respective units
                  legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
                ]
                \addplot+[red, mark options={red}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-object-original.csv};
                \addplot+[orange, mark options={orange}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-original.csv};
                \addplot+[blue, mark options={blue}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-elq.csv};
                %\addplot[dashed,red,domain=1:1500,samples=100] {5.567042796*10^(-6)*x^2 + 4.680174396*10^(-3)*x + 6.495754669*10^(-3)};
                %\addplot[dashed,orange,domain=1:1500,samples=100] {4.533208873*10^(-6)*x^2 + 6.320377596*10^(-4)*x + 2.289566005*10^(-2)};
                %\addplot[dashed,blue,domain=1:1500,samples=100] {4.071740702*10^(-8)*x^2 + 1.823749404*10^(-4)*x + 1.527042267*10^(-2)};
                \addlegendentry{Object-based approach}
                \addlegendentry{Scroll-based approach}
                \addlegendentry{ELQ scroll-based approach}
              \end{axis}
            \end{tikzpicture}
      \end{center}
      %\caption{Birds}
      % \end{wrapfigure}

    \noindent
    The plot compares the start-up performance
    of \elq{}'s scroll-based approach with the other two approaches.
    \elq{} achieves a 37-fold speedup compared to the object-based
    approach and a 17-fold speedup compared to the scroll-based
    approach when preparing 700 elements for resize detection.  It
    also performs well when detecting resize events, which it does
    with a delay of 25 ms for 100 elements.

    \comment{
    \begin{figure*}[h]
      \tiny
      \begin{center}
        \begin{minipage}[t]{.5\textwidth}
          \vspace{0pt}
          \centering
      \tiny
      \begin{tabular}[t]{ l l l l l l l }
        \multirow{2}{*}{Browsers} & \multicolumn{2}{c}{Injection} & \multicolumn{2}{c}{Resize detection} \\
        & scroll & object & scroll & object \\
        \hline
        Chrome v. 42                & 30 ms   & 550 ms    & 25 ms    & 20 ms  \\
        Firefox v. 40               & 150 ms  & 1000 ms   & 70 ms    & 30 ms  \\
        Safari v. 9                 & 100 ms  & 400 ms    & 30 ms    & 20 ms  \\
        Internet Explorer v. 11     & 350 ms  & 6700 ms   & 100 ms   & 80 ms  \\
        iOS Safari v. 9             & 350 ms  & 1600 ms   & 150 ms   & 60 ms  \\
        Android v. 5 Chrome v. 39   & 40 ms   & 1000 ms  & 20 ms     & 10 ms  \\
      \end{tabular}

        \end{minipage}%
        \begin{minipage}[t]{.5\textwidth}
          \vspace{0pt}
          \centering
          \begin{tikzpicture}
            \begin{axis}[
                width=\textwidth, % Scale the plot to \linewidth
                grid=major, % Display a grid
                grid style={dashed,gray!30}, % Set the style
                xlabel=Number of elements, % Set the labels
                ylabel=Injection time,
                y unit=s, % Set the respective units
                legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
              ]
              \addplot+[red, mark options={red}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-object-original.csv};
              \addplot+[orange, mark options={orange}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-original.csv};
              \addplot+[blue, mark options={blue}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-elq.csv};
              \addplot[dashed,red,domain=1:1500,samples=100] {5.567042796*10^(-6)*x^2 + 4.680174396*10^(-3)*x + 6.495754669*10^(-3)};
              \addplot[dashed,orange,domain=1:1500,samples=100] {4.533208873*10^(-6)*x^2 + 6.320377596*10^(-4)*x + 2.289566005*10^(-2)};
              \addplot[dashed,blue,domain=1:1500,samples=100] {4.071740702*10^(-8)*x^2 + 1.823749404*10^(-4)*x + 1.527042267*10^(-2)};
              \addlegendentry{Object-based approach}
              \addlegendentry{Scroll-based approach}
              \addlegendentry{ELQ scroll-based approach}
            \end{axis}
          \end{tikzpicture}
        \end{minipage}
      \caption{The left graph shows the injection time of the \elq{} scroll-based approach. The right graph shows all three approaches, including graph predictions by polynomial regression.}
      \label{fig:erd-elq-scroll}
      \end{center}
    \end{figure*}
    }

  %\newpage

  \comment{According to its website, ``Bootstrap is the most popular HTML, CSS, and JS framework for developing responsive, mobile first projects on the web.''~\cite{bootstrap}}

  \subsection{Case studies}
    \comment{
    We have adapted the popular Bootstrap~\cite{bootstrap} framework to use element queries instead of media queries.
    To modularize Bootstrap, we redefine the behavior of its responsive elements so that they no longer respond to the viewport but to enclosing container elements.
    The following observation guides our modularization: all responsive elements should respond to their closest enclosing \code{container} or \code{container-fluid} element.
    Both classes are used in Bootstrap to define new parts of a page (e.g., a grid is required to have a container ancestor).
    We also enable them to be nestable, which is important to satisfy the requirement of composable modules.
    The breakpoints of the container elements are defined using the \code{elq-breakpoints} API.
    Since the Bootstrap API uses a predefined set of breakpoints, they are all added to the container elements dynamically with JavaScript.
    According to this design, we convert all responsive elements of Bootstrap to \code{elq-mirror} elements, since they need to mirror the breakpoints of the nearest ancestor \code{elq-breakpoints} element.
    Since container elements may be nested, they have both the \code{elq-breakpoints} and \code{elq-mirror} behavior.

    The breakpoints of Bootstrap are defined as the following constants:\footnote{The Bootstrap CSS is generated using the LESS preprocessor~\cite{lesscss}.}
    \begin{lstlisting}[gobble=6,label={code:bootstrap-less-breakpoints},caption={},captionpos=b]]
      @screen-sm-min: 480px;
      @screen-md-min: 992px;
      @screen-lg-min: 1200px;
    \end{lstlisting}

    \noindent
    The following example shows how Bootstrap's style definitions are changed from using media queries to using \elq{}'s element queries:
    \begin{lstlisting}[gobble=6,label={code:bootstrap-less-breakpoints-usage},caption={},captionpos=b]]
      /* File "less/grid.less" of Bootstrap. */

      // Original Bootstrap using media queries.
      .container {
        @media (min-width: @screen-sm-min) {
          width: @container-sm;
        }
        ...
      }

      // ELQ Bootstrap using element queries.
      .container {
        &.elq-min-width-@{screen-sm-min} {
          width: @container-sm;
        }
        ...
      }
    \end{lstlisting}
    \noindent
    }

    \paragraph{Modularizing Bootstrap.}
    We have adapted the popular Bootstrap~\cite{bootstrap} framework
    to use element queries instead of media queries, to enable its use
    by responsive modules. By using CSS preprocessors to make the
    syntax of \elq{} element queries similar to media queries, only
    0.6\% of LOC changes were required.
    Our companion technical report~\cite{WienerEH15} provides more details,
    including code examples.
    In summary we have shown that
    it is easy to adapt existing responsive code to use \elq{}'s
    element queries instead of media queries.

    \paragraph{Industrial use of \elq{}.}
    We have also been gathering experience with the application of
    \elq{} in large financial applications developed at EVRY.
    Our practical experience shows that complex applications
    require a variety of features to be supported by element queries.
    Such features can be provided effectively by \elq{} plugins.
    We have noticed that in most of our responsive modules, it has been beneficial for us to use the JavaScript API
    to conditionally render whole chunks of HTML instead of only changing the style using CSS.
    Two teams at EVRY have independently come to this same conclusion, and have developed plugins to ease the usage with the different frameworks that the teams are using (Angular and React).

\section{Related Work}\label{sec:related}

  \paragraph{Syntax extensions.}
  The libraries~\cite{eq_imp_magichtml,eq_imp_eqcss,eq_imp_prollyfill-min-width,eq_imp_localised-css,eq_imp_gss} have in common that they require developers to write custom CSS, unlike \elq{}.
  Since they do not conform to the CSS standard, new features are supported through custom CSS parsed using JavaScript.
  As shown by \cite{eq_imp_eqcss,eq_imp_gss} quite advanced features can be implemented this way.
  Additionally, adding new CSS features implies that it is possible to implement a solution to element queries that does not require any changes to the HTML, which may be preferable since all styling then can be written in CSS.
  However, there are numerous drawbacks with libraries that require custom CSS.
  Extending the CSS syntax violates the requirement of compatability and also introduces a compilation step which decreases the performance \cite{elq-thesis}.

  \paragraph{Resize detection.}
  The libraries \cite{eq_imp_eqcss,eq_imp_breakpointsjs,eq_imp_mediaclass,eq_imp_elementquery,eq_imp_responsive-elements,eq_imp_sickles,eq_imp_responsive-elements-2,eq_imp_breaks2000,eq_imp_eqjs} simply observe the viewport resize event, which may be enough for static pages, but not enough to satisfy the requirements of reusable responsive modules \cite{elq-thesis}.
  Approach \cite{eq_imp_classquery} does not detect resize events at all.
  Like \elq{}, \cite{eq_imp_localised-css,eq_imp_selector_queries,eq_imp_prollyfill-min-width,eq_imp_gss,eq_imp_element-queries,eq_imp_css-element-queries} observe \emph{elements} for resize events.
  The libraries \cite{eq_imp_localised-css,eq_imp_selector_queries} use polling while \elq{} and \cite{eq_imp_prollyfill-min-width,eq_imp_gss,eq_imp_element-queries,eq_imp_css-element-queries} use different injection approaches.
  As shown in Section~\ref{sec:eval}, the injection approaches used by related libraries have significantly less performance than the element resizing detection system used in \elq{}.

  \paragraph{Constraint-based CSS.}
  CCSS~\cite{badros1999constraint} proposes a more general and flexible alternative to CSS.
  The idea of CCSS is to layout documents based on constraints.
  The Grid Style Sheets library \cite{eq_imp_gss} builds upon the ideas of CCSS.
  While not directly offering element queries, the library enables the possibility to conditionally style elements by element criteria and thus makes it a good candidate to solve the problem of responsive modules.
  However, the library has two major issues: performance and browser compatibility \cite{gss_issue}.
  In contrast, \elq{} only considers element queries, but without browser compatibility limitations and with higher performance.

\section{Conclusion}\label{sec:conclusion}
  %Responsive Web Design (RWD) enables web applications to adapt to the characteristics of different devices, which is achieved using CSS media queries.
  %However, using media queries it is impossible to create responsive applications in a modular way, because responsive elements then always depend on the global context.

  This paper extends Responsive Web Design (RWD) with {\em responsive
    modules} through element queries.  Our approach is the first to
  enable nested elements that are responsive in a modular way, i.e.,
  modules fully encapsulate any styling required for RWD.  Our
  implementation, \elq{}, is fully compatible with existing web
  standards and technologies. The element resize detection of \elq{}
  performs up to 37x better than previous algorithms.  We present a
  case study which shows that changing only about 0.6\% of the LOC is
  sufficient to enable the use of the popular Bootstrap framework in
  responsive modules.  We also report on first commercial usage of
  \elq{}.

  \comment{
  We believe \elq{} is an important contribution to realizing a
  modular form of element queries, in particular since standardization
  bodies like the RICG do not intend to standardize a complete
  solution.  In the future we intend to improve \elq{} by using
  forthcoming standards developed by the RICG to avoid some current
  limitations.}

%
% ---- Bibliography ----
%
\bibliographystyle{abbrv}
\bibliography{elq}  % elq.bib is the name of the Bibliography in this case
%
\end{document}
