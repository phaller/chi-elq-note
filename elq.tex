% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@hq.acm.org
%
% For tracking purposes - this is V3.1SP - APRIL 2009

\documentclass{acm_proc_article-sp}

\usepackage{tikz}
\usetikzlibrary{arrows,positioning,fit,calc,decorations.markings}
\usepackage{pgfplots}
\pgfplotsset{compat=newest} % Allows to place the legend below plot
\usepgfplotslibrary{units} % Allows to enter the units nicely
\usepackage{multirow}
\usepackage{url}
\usepackage{listings}
\lstset{
  basicstyle=\scriptsize
}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\elq}{ELQ}
\newcommand{\glspl}[1]{#1}
\newcommand{\gls}[1]{#1}
\newcommand{\todo}[1]{}

\begin{document}

\title{Allowing Responsive Web Modules}
\subtitle{}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
  Ben Trovato\\
  \affaddr{Institute for Clarity in Documentation}\\
  \affaddr{1932 Wallamaloo Lane}\\
  \affaddr{Wallamaloo, New Zealand}\\
  \email{trovato@corporation.com}
% 2nd. author
\alignauthor
  G.K.M. Tobin\\
  \affaddr{Institute for Clarity in Documentation}\\
  \affaddr{P.O. Box 1212}\\
  \affaddr{Dublin, Ohio 43017-6221}\\
  \email{webmaster@marysville-ohio.com}
% 3rd. author
\alignauthor
  Lars Th{\o}rv{\"a}ld\\
  \affaddr{The Th{\o}rv{\"a}ld Group}\\
  \affaddr{1 Th{\o}rv{\"a}ld Circle}\\
  \affaddr{Hekla, Iceland}\\
  \email{larst@affiliation.org}
}

% TODO: Add line number for listings.

\date{10 October 2015}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}
  Responsive Web Design (RWD) enables web application to adapt to the characteristics of different devices such as screen size which is important for mobile browsing.
  Today, the only W3C standard to support this adaptability is CSS media queries.
  However, using media queries it is impossible to create applications in a modular way, because responsive elements then always depend on the global context.
  Hence, responsive elements can only be reused if the global context is exactly the same, severely limiting their reusability.
  This makes it extremely challenging to develop large responsive applications, because the lack of true modularity makes certain requirement changes either impossible or expensive to realize.

  In this paper we extend RWD to also include responsive modules, i.e., modules that adapt their design based on their local context independently of the global context.
  We present the \elq{} project which implements our approach.
  \elq{} is a novel implementation of so-called \emph{element queries} which generalize media queries.
  Importantly, our design conforms to existing web specifications, enabling adoption on a large scale.
  \elq{} is designed to be heavily extensible using plugins.
  Experimental results show speed-ups of the core algorithms of up to 37x compared to previous approaches.

\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{Theory}

\keywords{ACM proceedings, \LaTeX, text tagging} % NOT required for Proceedings

\section{Introduction}
  % \begin{itemize}
  %   \item Why modules? Reusability (even across applications), reduced code complexity.
  %   \item Why responsive design?
  %   \item Responsive Modules of today need to be context aware (thus, not very reusable [they only work in a specific layout]).
  %   \item What do we want and why? Modules that are responsive relative to its outer frame.
  % \end{itemize}

  Responsive Web Design (RWD) is an approach to make an application respond to the viewport size and device characteristics.
  This is currently achieved by using CSS media queries that are designed to conditionally design content by the media, such as using serif fonts when printed and sans-serif when viewed on a screen.

  In order to reduce complexity and enable reusability applications are typically composed of modules, i.e., interchangeable and independent parts that have a single and well-defined responsibility \cite{parnas1972criteria}.
  In order for a module to be reusable it must not assume in which context it is being used.

  In this paper we focus on the presentation layer of web applications.
  As it stands, using media queries to make the presentation layer responsive precludes modularity.
  The problem is that there is no way to make a module responsive without it being context-aware, due to media queries only being able to target the viewport.
  Thus, a responsive module using media queries is layout dependent and has therefore limited reusability.
  Therefore, media queries can only be used for RWD of non-modular static applications.
  In a world where no better solution than media queries exists for RWD, changing the layout of a responsive application becomes a cumbersome task.

  \subsection{The Problem Exemplified}
    % \begin{itemize}
    %   \item MQ is not the solution to RWD. (MQ was not designed for RWD as the feature was released long before RWD)
    %   \item All elements adapt their inner design by the viewport width.
    %   \item Menu Example shows how MQ are broken.
    %   \item Limitations of MQ regarding font-size (em).
    % \end{itemize}
    
    Imagine an application that displays the current weather of various cities as widgets, by using a weather widget module.
    The module should be responsive, so that more information such as a temperature graph over time is displayed when the widget is big.
    When the widget is small it should only display the current temperature.
    Users should also be able to add, remove and resize widgets.

    Such application cannot be built with media queries, since the widgets can have varying sizes independent of the viewport (e.g., the width of one widget is 30\% while another is 40\%).
    To overcome this problem we must change the application so that widgets always have the same sizes.
    This implies that the size of the module and the media query breakpoints are coupled/intertwined, i.e. they are proportional to each other.
    % If we also assume that all widgets always have a fixed percentage, for example 25\% of the viewport width, it is possible to make the module responsive by using media queries.
    The problem now is that we have removed the reusability of the weather module, since it requires the specific width that is correctly proportional to the media query breakpoints. 
%    The problem now is that we have removed the reusability of the weather module, since it may only be used in applications that grant it 25\% of the viewport width.

    Imagine a company working on a big application that uses media queries for responsiveness (i.e., each responsive module assumes to have a specific percentage of the viewport size).
    The ability to change is desired by both developers and stakeholders, but is limited by this responsive approach.
    The requirement of changing a menu from being a horizontal top menu to being a vertical side menu implies that all responsive modules break since the assumed proportionality of each module is changed.
    Even worse, if the menu is also supposed to hide on user input the responsiveness of the module breaks since the layout changes dynamically.
    The latter requirement is impossible to satisfy without element queries.

    Additionally, it is popular to define breakpoints relative to the font size.
    Media queries can only target the font size of the document root, limiting the functionality drastically.
    With element queries, breakpoints may be defined relative to the font size of the targeted element.

    As we can see, even with limited requirements there still are significant flaws with using media queries for responsive modules.

    \label{sec:reqs}
    \subsection{Requirements}
      % \begin{itemize}
      %   \item Parents should decide the layout of their children, and the children should adapt their inner design accordingly.
      %   \item Valid language syntaxes (HTML, CSS, JS).
      % \end{itemize}

      The desired behavior of a responsive module is having its inner design responding to the size of \emph{its container} instead of the viewport.
      Only then is a responsive module independent of its layout context.
      Realizing responsive modules requires CSS rules that are conditional upon \emph{elements}, instead of the global viewport.

      \begin{itemize}
        \item 
          A solution must provide a possibility for an element to change depending on the properties of the parent element.
          Elements should automatically respond to changes of the parent size so that the correct design can be presented for each size.
        \item
          A solution must conform to the syntax of HTML, CSS, and JavaScript so that the compatability of tools, libraries and existing projects is retained.
        \item
          A solution must have adequate performance for large applications that make heavy use of responsive modules.
        \item Extensibility
        \item Composability
      \end{itemize}

    \subsection{Approach}
      In this paper we extend the concept of RWD to also include responsive modules.
      The W3C has discussed such a feature under the name of \emph{element queries} given its analogy to media queries.
      This paper presents a novel implementation of element queries in JavaScript named \elq{}, and discusses the new possibilities of GUI design that our implementation enables.

      Our approach is implemented as a client side library to be included in applications.
      One could argue that a solution does not need to be executed on the client side, but instead generate media queries on the server side for all modules with respect to the current application layout.
      However, this is insufficient due to the modules then being limited to applications with static layouts.
      Also, the generated media queries would not be able to respond to the user changing properties of elements such as layout and font size.

    \subsection{Contributions}
      This paper makes the following contributions:
      \begin{itemize}
        \item A new design that enables responsive modules while conforming to the syntax of HTML, CSS, and JavaScript.
        \item
          % encapsulation of CSS based styling of elements.
          Our approach is the first to enable nested elements that are responsive in a modular way, i.e., styling required for RWD is fully encapsulated in the module.
          As a side effect, responsive modules may also be arbitrarily styled with CSS independently of their context.
          % An approach that enables encapsulated styling of modules crucial for element queries, such as .
          % As a result, responsive modules using \elq{} may also be nested.
        \item
          An extensible library architecture that enables plugins to significantly extend the behavior of the library.
          This makes it possible to create plugins in order to ease integration of \elq{} into existing modules or libraries.
        \item
          A new implementation technique that offers substantially higher performance than previous approaches.
          Our technique batch processes DOM operations so that layout thrashing (i.e., forcing the layout engine to perform multiple independent layouts) is avoided.
      \end{itemize}

    The rest of the paper is organized as follows:


\section{Background}
  \begin{itemize}
    \item Explain media queries really short (simple example). Maybe explain some terminology.
  \end{itemize}

  Media queries and element queries are similar in the sense that they both enable developers to define conditional style rules that are applied by specified criteria.
  The main difference is the type of criteria that can be used; in media queries device, document, and media criteria are used, while element criteria are used in element queries.
  It can somewhat simplified be described as that media queries target the document root and up (i.e., the viewport, browser, OS, device, input mechanisms, etc.) while element queries target the document root and down (i.e., elements of the document).

\section{Overview of \elq{}}
  To enable element queries today, we have developed a novel JavaScript implementation named \elq{}.
  Our implementation satisfied all requirements given in~\ref{sec:reqs}.
  The library have been designed to conform to the standards and specifications of the web languages while providing the features required of building advanced constellations of responsive modules.
  The novelty lies in having significantly improved performance by batch processing DOM operations, and providing an API that enables nesting of modules.
  \elq{} also has excellent browser compatability as it supports Internet Explorer 8 and upwards.

  \elq{} is designed to be plugin-based for increased flexibility and extensibility.
  By providing a good library foundation and plugins it is up to developers to choose the right plugins for each project.
  In addition, by letting the plugins satisfy the requirements it is easy to extend the library with new plugins when new requirements arise.

  An \emph{element breakpoint} is defined as a point of an element property range which can be used to define conditional behavior, similar to breakpoints of media queries.
  For example, an element breakpoint of 500 pixels in width enables conditional styling depending on if the element is narrower or wider than 500 pixels.
  An element may have multiple breakpoints.
  An \emph{element breakpoint state} is defined as the state of the element breakpoint relative to the current element property value.
  For example, if an element that is 300 pixels wide has two width breakpoints of 200 and 400 pixels the element breakpoint states are ``wider than 200 pixels'' and ``narrower than 400 pixels''.

  When the breakpoint states of an element changes, \elq{} performs cycle detection in order to detect and handle possible cyclic element queries.
  If a cycle is detected, the new element breakpoint states are not applied in order to avoid an infinite cycle.
  The cycle detection system is implemented as an conservative algorithm, and may detect false positives.

  \subsection{The API}
    As CSS 3 does not support custom at-rules/selectors, responsive elements are annotated in HTML by element attributes.
    The main idea is to annotate elements with breakpoints of interest so that children can be conditionally styled in CSS by targeting the different element breakpoint states.
    In this example, we will use the \code{elq-breakpoints} plugin that observers the element in order to automatically update the breakpoint classes.
    Although not written in the examples, the library also supports attributes defined with the \code{data-} prefix to conform to the HTML standard.

    In listing~\ref{code:elq-breakpoints-example} we see an element that has annotated two breakpoints at 300 and 500 pixels.

    \begin{lstlisting}[gobble=6,caption={},captionpos=b,label={code:elq-breakpoints-example}]]
      <div class="foo" elq elq-breakpoints
        elq-breakpoints-widths="300 500">
        
        <p>When in doubt, mumble.</p>
      </div>
    \end{lstlisting}

    When \elq{} has processed the element, it will always have two classes, one for each breakpoint, that tells if the size of the element is greater or lesser than each breakpoint.
    For instance, if the element is 400 pixels wide, the element has the two classes \code{elq-min-width-300px} and \code{elq-max-width-500}.
    Similarly, if the element is 200 pixels wide the element the classes are instead \code{elq-max-width-300px} and \code{elq-max-width-500}.
    So for each breakpoint only the min/max part changes.
    It may seem alien that the classes describe that the width of the element is both maximum 300 and 500 pixels.
    This is because we have taken a user-centric approach, so that when using the classes in CSS the API is similar to element queries.
    However, developers are free to change this API at will as \elq{} is plugin-based.

    Now that we have defined the breakpoints of the element, we can conditionally style it by using the classes.
    See listing~\ref{code:elq-breakpoints-example-css} for an example of how the classes can be used.

    \begin{lstlisting}[gobble=6,caption={},captionpos=b,label={code:elq-breakpoints-example-css}]]
      .foo.elq-min-width-300px.elq-max-width-500px {
        background-color: green;
      }

      .foo.elq-min-width-500px {
        background-color: blue;
      }

      .foo.elq-max-width-500px p {
        color: white;
      }
    \end{lstlisting}

    \subsubsection{Nested modules}
      This API is sufficient for applications that do not need nested breakpoint elements, and similar features is provided by related libraries.
      However, using such API in responsive modules still limits the reusability since the modules then may not exist in an outer responsive context.
      Also, it is customary to compose large/complex modules by smaller modules that may also need to be responsive \cite{parnas1972criteria}.

      The reason this API is not sufficient for nested modules is because there is no way to limit the CSS matching search of the selectors.
      The selector of the last example given in listing~\ref{code:elq-breakpoints-example-css} specifies that all paragraph elements should have white text if \emph{any} ancestor breakpoints element is above 500 pixels wide.
      Since the ancestor selector may match elements outside of the module, such selectors are dangerous to use in the context of responsive modules.
      The problem may be somewhat reduced by more specific selectors and such, but it cannot be fully solved for arbitrary styling.

      To solve this problem, we provide a plugin that let us define elements to ``mirror'' the breakpoints classes of the nearest ancestor breakpoints element.
      Then, the conditional style of the mirror element may be written as a combinatory selector that is relative to the nearest ancestor breakpoints element.
      See listing~\ref{code:elq-mirror-example} for example markup of the mirror plugin to enable nested modules.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:elq-mirror-example}]]
        <div class="foo" elq elq-breakpoints
          elq-breakpoints-widths="300 500">
          
          <div class="foo" elq elq-breakpoints
            elq-breakpoints-widths="300 500">

            <p elq elq-mirror>...</p>
          </div>

          <p elq elq-mirror>...</p>
        </div>
      \end{lstlisting}

      As the paragraph elements are mirroring the nearest \code{.foo} ancestor, we can now write CSS as shown in listing~\ref{code:elq-mirror-example-css}.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:elq-mirror-example-css}]]
        .foo {
          /* So that the nested module 
             behaves differently */
          width: 50%;
        }

        .foo p.elq-max-width-500px {
          color: white;
        }
      \end{lstlisting}

      Since we in the previous examples have annotated elements manually, the power and flexibility of the API have not been properly displayed.
      Only when combined with JavaScript, things get more interesting.
    \subsubsection{A high-level API}
      To further prove the potential of \elq{}, we have created a plugin that enables a high-level API for responsive modules.
      The API enables developers to use resposnive grids and utility classes very similar to the ones defined by the CSS Bootstrap framework.
      See listing~\ref{code:bootstrap-grid-example} for an example grid that uses the Bootstrap API.
      The example grid is defined to be single columned for small viewports, triple columned for medium viewports, and double columned for large viewports.
      It should be noted that the last column is hidden for large viewports.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:bootstrap-grid-example}]]
        <div class="container">
          <div class="row">
            <div class="col-md-4 col-lg-6">
              ...
            </div>
            <div class="col-md-4" col-lg-6>
              ...
            </div>
            <div class="col-md-4 hidden-lg-up">
              ...
            </div>
          </div>
        </div>
      \end{lstlisting}
      
      This API uses media queries and supports a fixed set of breakpoints that can be used to determine when the grid should change layout (depending on the viewport size).
      The column classes defines the behaviour of the grid, and has the syntax \code{col-[breakpoint]-[size]}.
      The predefined breakpoints are \code{xs, sm, md, lg} and the size may be between 1 and 12.

      The syntax of our API does not differ much from the Bootstrap API, but the behavior does.
      The columns of our API responds to the parent \code{row} instead of the viewport.
      Therefore, we have altered the column classes to also accept custom breakpoints so that developers have full control of the grid behavior.
      The \code{breakpoint} part of the column class can be any positive number, and may optionally be postfixed with a unit.
      Currently, the supported units are \code{px, em, rem}.
      If the units is omitted, \code{px} is assumed.
      See listing~\ref{code:elq-grid-example} for an example grid that uses our API.
      The example grid is defined to be single columned when the width of the grid is below 500 pixels, triple columned when the width is between 500 and 700 pixels, and double columned for when the width is above 700 pixels.
      It should be noted that the last column is hidden when the width is above 700 pixels.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:elq-grid-example}]]
        <div class="container">
          <div class="row">
            <div class="col-500-4 col-700-6">
              ...
            </div>
            <div class="col-500-4" col-700-6>
              ...
            </div>
            <div class="col-500-4 hidden-700-up">
              ...
            </div>
          </div>
        </div>
      \end{lstlisting}

      This enables developers to define grid behaviors by pixel precision in nestable modules, while maintaing the familiar Bootstrap API style.

      % TODO: Write how to start elq, and that is is up to developers how this should be done.

\section{Extensions via plugins}
  One our of contributions is to allow \elq{} to be easily extended with plugins.
  For example, if annotating HTML is undesired it is possible to create a plugin that instead parses CSS.
  Likewise, if adding breakpoint classes to element is undesired it is possible to create a plugin that does something else when an element breakpoint state of an element has changed.
  In order to enable such powerful behavior alterings by plugins, extensibility has been the main focus when designing the \elq{} architecture.

  A plugin is defined by a \emph{plugin definition object} and has the structure shown in listing~\ref{code:elq-plugin-definition}.
  \begin{lstlisting}[gobble=4,caption={},captionpos=b,label={code:elq-plugin-definition}]]
    var myPluginDefinition = {
      getName: function () {
          return "my-plugin";
      },
      getVersion: function () {
          return "0.0.0";
      },
      isCompatible: function (elq) {
          return true;
      },
      make: function (elq, options) {
          return {
            // Implement plugin instance methods.
            ...
          };
      }
    };
  \end{lstlisting}

  All of the methods are invoked when registered to an \elq{} instance.
  The \code{getName} and \code{getVersion} methods tells the name and version of the plugin.
  The \code{isCompatible} tells if the plugin is compatible with the \elq{} instance that it is registered to.
  In the \code{make} method the plugin may initialize itself to the \elq{} instance and return an object that defines the API accessible by \elq{} and other plugins.

  When necessary, \elq{} invokes certain methods of the plugin API, if implemented, to let plugins decide the behavior of the system.
  Those methods are the following:
  \begin{itemize}
    \item \code{start(element)}
          Called when an element is requested to be started, in order for plugins to initialize listeners and element properties.
    \item \code{getElements(element)}
          Called in order to let plugins reveal extra elements to be started in addition to the given element.
    \item \code{getBreakpoints(element)}
          Called to retrieve the current breakpoints of an element.
    \item \code{applyBreakpointStates(element, breakpointStates)}
          Called to apply the given element breakpoint states of an element.
  \end{itemize}

  In addition, plugins may also listen to the following \elq{} events:
  \begin{itemize}
    \item \code{resize(element)}
          Emited when an \elq{} element has changed size.
    \item \code{breakpointStatesChanged(element, breakpointStates)}
          Emited when an element has changed element breakpoint states (e.g., when the width of an element changed from being narrower than a breakpoint to being wider).
  \end{itemize}

  There are two main flows of the \elq{} system; starting an element and updating an element.
  When \elq{} is requested to start an element, the following flow occurs:

  TODO: Use active voice.

  \begin{enumerate}
    \item The element is intialized by installing properties and a system handling listeners.
    \item 
          The \code{getElements} method of all plugins is called to retrieve any additional elements to start.
          Additonal elements will go through an own flow.
    \item The \code{start} method of all plugins is called so that plugin specific initialized may occur.
    \item If any plugin has requested \elq{} to detect resize events of the element, an resize detector is installed.
    \item The element is passed through the update flow.
  \end{enumerate}


  The update flow is as follows:
  \begin{enumerate}
    \item The \code{getBreakpoints} method of all plugins is called to retrieve all breakpoints of the element.
    \item Element breakpoint states are calculated.
    \item If any state has changed since the previous update:
    \begin{enumerate}
      \item Perform cycle detection. If a cycle is detected, then abort the flow and emit a warning.
      \item The \code{applyBreakpoints} method of all plugins is called. TODO: Rename to applyBreakpointStates.
      \item The \code{breakpointStatesChanged} event is emited.
    \end{enumerate}
  \end{enumerate}

  Of course, there are options to disable some of the steps such as cycle detection and applying breakpoint states.
  In additon to being triggered by the start flow and plugins, it is also triggered by element resize events.

  TODO: Explain that plugins may set properties of element.elq, and also use the elq plugin API.

  \subsection{Example Plugin Implementation}
    The \code{elq-breakpoints} API that enables developers to annotate breakpoints in HTML, as described in section~\ref{}, is implemented as two plugins.
    This shows that even the core functionality of \elq{} is implemented in terms of plugins.
    The first plugin parses the breakpoints of the element attributes.
    The second plugin applies the breakpoint states as classes.

    The simplified code of the \code{make} method of the parsing plugin is presented in listing~\ref{}.

    TOOD: Write that the following is the implementation of the make method of the previous shown plugin definition (line number reference).

    \begin{lstlisting}[gobble=6,caption={},captionpos=b,label={}]]
      function start(element) {
          if (!element.hasAttribute("elq-breakpoints")) {
              return;
          }

          element.elq.resizeDetection = true;
          element.elq.updateBreakpoints = true;
          element.elq.applyBreakpoints = true;
          element.elq.cycleCheck = true;
          // TODO: Use Detection instead of Check, 
          // to be consistent.
      }

      function getBreakpoints(element) {
        // Parse the "elq-breakpoints-*" attributes
        // and retrieve their breakpoints.
        return ...;
      }

      // Return the plugin API
      return {
          start: start,
          getBreakpoints: getBreakpoints
      };
    \end{lstlisting}

    The applying plugin simply implements the \code{applyBreakpoints} method to alter the \code{className} property of the element by the given element breakpoint states.

    TODO: Explain the code a bit more, what's happening?


\section{Implementation}
  Batching.
  Resize listening.

\section{Empirical evaluation}
  \subsection{Performance}
    The following tests were performed on a computer with a 2.5 GHz processor and 16 GB of memory\footnote{The serial number of the computer is C02N4G9TG3QD and the vendor is Apple Inc. CPU: 2.5 GHz Intel Core i7. Memory: 16 GB 1600 MHz DDR3. GPU: Intel Iris Pro 1536 MB.}.
    The library has been tested in the following browsers: Chrome 42.0.2311.152, Firefox 37.0.1 and Safari 8.0.6.
    Measurements and graphs show evaluations performed in Chrome unless stated otherwise.

    % Have this here?
    % Since the algorithm neither interacts with the \gls{DOM}, handles any large data structures, or performs any heavy computations it is very fast.
    % It takes \textasciitilde0.02 ms to execute the \code{isUpdateCyclic} function.
    % \todo{Should this measurement be given in eval? But then eval will be really small?}
    % See figure~\ref{} for a timeline of the \code{elq-breakpoints} plugin handling a resize event, where it is visually shown how insignificant the impact of the cycle detector system has on the total performance.

    \todo[inline]{Include evaluation about the cycle detector?}
    \todo[inline]{Write about the new "noclasses" option, and maybe flesh out the interplugin API section?}
    \todo[inline]{Write that as ELQ is plugin-based, it makes sense to measure the core subsystems by themselves and the plugins enabling element queries in different setups.}
    \todo[inline]{Have to measure how elq-breakpoints handles large amount of elements. It might suffor from layout thrashing since might read/write the DOM at invalid stages of the erd subsystem.}
    \todo[inline]{Actually since elq-breakpoints is batch-processed, no layout thrashing occurs. However, two disjunct layouts are performed (one for the erd system and one for the plugin) which could theoretically be merged.}
    \todo[inline]{Philipp: If possible, show graphs for other browsers than Chrome.}
    \todo[inline]{Write about Bootstrap performance here.}

    
    %\subsection{Element resizing detection}\label{sec:eval-perf-erd}
      This section evaluates the performance of the object-based and scroll-based solutions to detecting \gls{element} resize events described in Section~\ref{sec:imp_erd}.
      The optimized \gls{ELQ} version of the scroll-based solution is also evaluated.
      Since the element resizing detection subsystem performs the heaviest tasks, only the performance of that subsystem is evaluated.
      The other subsystems entail no significant performance penalties.
      \todo{Remove this, and analyze the different subsystems in detail: erd, cycle detector, elq-breakpoints, etc.}

      The object-based solution performs well when detecting resize events.
      However, injecting \code{object} elements is quite a heavy task.
      See figure~\ref{fig:erd-original-object} for graphs that show the performance of the object-based solution.
      As shown by the graphs, the injection can be performed with adequate performance as long as the number of elements is low.
      The solution does not scale well as the number of elements increases.
      \todo{Maybe be less pessimistic as Safari might have to use the object solution?}
      \begin{figure*}[h]
        \tiny
        \begin{center}
          \begin{minipage}[t]{.5\textwidth}
            \vspace{0pt}
            \centering
              \begin{tikzpicture}
                \begin{axis}[
                    width=\textwidth, % Scale the plot to \linewidth
                    grid=major, % Display a grid
                    grid style={dashed,gray!30}, % Set the style
                    xlabel=Number of elements, % Set the labels
                    ylabel=Injection time,
                    y unit=s, % Set the respective units
                    legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
                  ]
                  \addplot+[red, mark options={red}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-object-original.csv};
                  \legend{Object-based solution}
                \end{axis}
              \end{tikzpicture}
          \end{minipage}%
          \begin{minipage}[t]{.5\textwidth}
            \vspace{0pt}
            \centering
            \begin{tikzpicture}
              \begin{axis}[
                  width=\textwidth, % Scale the plot to \linewidth
                  grid=major, % Display a grid
                  grid style={dashed,gray!30}, % Set the style
                  xlabel=Number of elements, % Set the labels
                  ylabel=Heap memory usage,
                  y unit=MB, % Set the respective units
                  legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
                ]
                \addplot+[red, mark options={red}]
                % add a plot from table; you select the columns by using the actual name in
                % the .csv file (on top)
                table[x=n elements,y=memory,col sep=comma] {./data/erd-object-original.csv};
                \legend{Object-based solution}
              \end{axis}
            \end{tikzpicture}
          \end{minipage}
        \caption{The injection performance of the object-based solution. The left graph shows the injection time. The right graph shows the heap memory used when all \code{object} \glspl{element} have been injected.}
        \label{fig:erd-original-object}
        \end{center}
      \end{figure*}

      % See figure~\ref{fig:erd-elq-scroll} for graphs that show how the \gls{ELQ} scroll-based solution performs compared to the other solutions.
      % As evident in the figure, the optimized \gls{ELQ} solution has significantly reduced installation times compared to the other two.
      % The \gls{ELQ} solution also scales better, as more clearly shown in figure~\ref{fig:erd-solutions-regressed} that includes polynomial regression graphs for all three solutions.
      % Both scroll-based solutions have the same memory footprint (i.e., too low for reliable measurements).

      The scroll-based solution also performs well when detecting resize events.
      As no \code{object} \glspl{element} are injected the memory footprint is reduced significantly, which improves the injection performance.
      See figure~\ref{fig:erd-original-scroll} for graphs that show how both solutions perform compared to each other.
      It is clear that the scroll-based solution both performs and scales better than the object-based solution during injection.        
      The amount of memory used by the scroll-based solution is so low that reliable measurements could not be gathered, as the number of \glspl{element} was not high enough to affect the memory usage noticeably.

      Recall that the scroll-based solution was rewritten and optimized, which is referred to as the \gls{ELQ} scroll-based solution.
      By avoiding \gls{layout thrashing}, the injection performance was improved significantly.
      See figure~\ref{fig:erd-elq-scroll} for graphs that show how it performs compared to the other solutions.
      As evident in the figure, the optimized \gls{ELQ} solution has significantly reduced injection times compared to the other two.
      It achieves a 32-fold speedup compared to the object-based solution and a 13-fold speedup compared to the scroll-based solution when preparing 500 \glspl{element} for resize detection.
      The \gls{ELQ} solution also scales better, as more clearly shown in figure~\ref{fig:erd-solutions-regressed} that includes polynomial regression graphs for all three solutions.
      Both scroll-based solutions have the same memory footprint (i.e., too low for reliable measurements).
      \begin{figure*}[h]
        \tiny
        \begin{center}
          \begin{minipage}[t]{.5\textwidth}
            \vspace{0pt}
            \centering
              \begin{tikzpicture}
                \begin{axis}[
                    yticklabel style={
                            /pgf/number format/fixed,
                            /pgf/number format/precision=5
                    },
                    scaled y ticks=false,
                    width=\textwidth, % Scale the plot to \linewidth
                    grid=major, % Display a grid
                    grid style={dashed,gray!30}, % Set the style
                    xlabel=Number of \glspl{element}, % Set the labels
                    ylabel=Injection time,
                    y unit=s, % Set the respective units
                    legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
                  ]
                  \addplot+[blue, mark=diamond*, mark options={blue}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-elq.csv};
                  \addlegendentry{ELQ scroll-based solution}
                \end{axis}
              \end{tikzpicture}
          \end{minipage}%
          \begin{minipage}[t]{.5\textwidth}
            \vspace{0pt}
            \centering
            \begin{tikzpicture}
              \begin{axis}[
                  width=\textwidth, % Scale the plot to \linewidth
                  grid=major, % Display a grid
                  grid style={dashed,gray!30}, % Set the style
                  xlabel=Number of \glspl{element}, % Set the labels
                  ylabel=Injection time,
                  y unit=s, % Set the respective units
                  legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
                ]
                \addplot+[red, mark options={red}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-object-original.csv};
                \addplot+[orange, mark options={orange}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-original.csv};
                \addplot+[blue, mark=diamond*, mark options={blue}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-elq.csv};

                \addlegendentry{Object-based solution}
                \addlegendentry{Scroll-based solution}
                \addlegendentry{ELQ scroll-based solution}
              \end{axis}
            \end{tikzpicture}
          \end{minipage}
        \caption{The injection performance of the optimized \gls{ELQ} scroll-based element resizing detection solution. The left graph shows the injection time of the \gls{ELQ} scroll-based solution. The right graph shows all three solutions for comparison. The heap memory usage graph has been omitted as the memory usage of the scroll-based solutions is too low for reliable measurements.}
        \label{fig:erd-elq-scroll}
        \end{center}
      \end{figure*}

      \begin{figure}[h!]
        \tiny
        \begin{center}
          \centering
          \begin{tikzpicture}
            \begin{axis}[
                width=0.5\textwidth, % Scale the plot to \linewidth
                grid=major, % Display a grid
                grid style={dashed,gray!30}, % Set the style
                xlabel=Number of \glspl{element}, % Set the labels
                ylabel=Injection time,
                y unit=s, % Set the respective units
                legend style={at={(0.5,-0.20)},anchor=north} % Put the legend below the plot
              ]
              \addplot+[red, mark options={red}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-object-original.csv};
              \addplot+[orange, mark options={orange}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-original.csv};
              \addplot+[blue, mark options={blue}] table[x=n elements,y=injection time,col sep=comma] {./data/erd-scroll-elq.csv};
              \addplot[dashed,red,domain=1:1500,samples=100] {5.567042796*10^(-6)*x^2 + 4.680174396*10^(-3)*x + 6.495754669*10^(-3)};
              \addplot[dashed,orange,domain=1:1500,samples=100] {4.533208873*10^(-6)*x^2 + 6.320377596*10^(-4)*x + 2.289566005*10^(-2)};
              \addplot[dashed,blue,domain=1:1500,samples=100] {4.071740702*10^(-8)*x^2 + 1.823749404*10^(-4)*x + 1.527042267*10^(-2)};
              \addlegendentry{Original object-based solution}
              \addlegendentry{Scroll-based solution}
              \addlegendentry{ELQ scroll-based solution}
            \end{axis}
          \end{tikzpicture}
        \caption{The injection performance of all three solutions including graph predictions by polynomial regression.}
        \label{fig:erd-solutions-regressed}
        \end{center}
      \end{figure}

      \paragraph{Firefox and Safari}
      As shown, great performance can be achieved with the optimized \gls{ELQ} scroll-based solution in Chrome.
      Unfortunately, there is no silver bullet to observing element resize events; as the other \glspl{browser} behave differently.
      See table~\ref{table:erd-layout-engines} for the performance of the object-based and scroll-based solutions operating on 100 \glspl{element} in different \glspl{browser}.
      The \gls{ELQ} scroll-based solution is preferred for Chrome, as the injection is 32-fold faster (when operating on 500 \glspl{element}) than the object-based solution while the resize detection performance is the same for both solutions.
      In Firefox, the object-based solution detects resize events 2-fold faster than the \gls{ELQ} scroll-based solution when operating on 100 \glspl{element} (still, 100 ms for detecting resize events is acceptable).
      However, the injection time needed for the object-based solution is 5.5-fold of the time needed for the \gls{ELQ} scroll-based solution.
      The \gls{ELQ} scroll-based solution is therefore probably desired in Firefox for the general use case (as described in Section~\ref{sec:eq-definitions}).
      In Safari, the \gls{ELQ} scroll-based solution detects resize events in 800 ms while the object-based solution detects them in 25 ms, which of course is unacceptable.
      Unfortunately, the injection time needed for the object-based solution is 3-fold slower than the \gls{ELQ} scroll-based solution.
      Since a delay of 800 ms when detecting resize events is undesired in most use cases, the object-based solution is preferred for Safari.
      Recall from Section~\ref{sec:imp_erd} that this is due to WebKit and Gecko not being able to queue the scroll mutation operations as Blink does.
      \begin{table}[ht]\center
        \tiny
        \begin{tabular}[t]{ l l l l l l l }
          \multirow{2}{*}{Layout engine} & \multicolumn{2}{c}{Injection} & \multicolumn{2}{c}{Resize detection} \\
          & scroll & object & scroll & object \\
          \hline
          \gls{Blink}   & \textbf{30 ms}   & 600 ms    & 30 ms   & 30 ms           \\
          \gls{Gecko}   & \textbf{200 ms}  & 1100 ms   & 100 ms  & \textbf{50 ms}  \\
          \gls{WebKit}  & \textbf{100 ms}  & 300 ms    & 800 ms  & \textbf{25 ms}  \\
        \end{tabular}
        \caption{Performance of the object-based and \gls{ELQ} scroll-based solutions in different \glspl{layout engine} when operating on 100 \glspl{element}.}
        \label{table:erd-layout-engines}
      \end{table}

      \todo[inline]{Present perf statistics of other browsers? Firefox still seems to favor the scroll solution (but less performant) while Safari semms to favors the object solution.}
      \todo[inline]{Show graph for resize detection also.}
      \todo[inline]{Graphs for Firefox, IE and Safari?}
  \subsection{Case studies}
    Plugins makes it easy to integrate.



\section{Discussion}
  \begin{itemize}
    \item Performance, APIs, Features.
    \item The mirror functionality of \elq{} makes it uniquely suitable for nested modules.
  \end{itemize}

  \subsection{Limitations}
    (Drawbacks)
    No good alternative.
    Mention RICG (perhaps standard that solves the issue in the future).


  \subsection{Standardization}
    It is stated on the W3C's www-style mailing list \cite{w3c_eq_mail} by Zbarsky of Mozilla, Atkins of Google and Sprehn of Google that element queries are infeasible to implement without restricting them.
    By limiting element queries to specially separated container elements that can only be queried by child elements, many of the problems are resolved \cite{ricg_irc_log,ricg_issue_viewport}.
    Therefore, the Responsive Issues Community Group (RICG) is currently investigating the possibility of standardizing \emph{container} queries.

    Unfortunately, even such limited container queries requires significant effort to implement \cite{ricg_issue_viewport}.
    Atkins argues that a correct and full implementation is unlikely to be implemented, and therefore it might be wiser to pursue sub-standards that aids third-party solutions instead.
   
    In the future, we hope that Elq may use the aiding sub-standards pushed by RICG, to achieve greater flexibility and performance.

    We want RICG to standardize the following: bla bla bla

\section{Related Work}
  

\section{Conclusions}
  \begin{itemize}
    \item Production ready.
    \item Probably no standard (or not in a long time).
  \end{itemize}

%\end{document}  % This is where a 'short' article might terminate

%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
This section is optional; it is a location for you
to acknowledge grants, funding, editing assistance and
what have you.  In the present case, for example, the
authors would like to thank Gerald Murray of ACM for
his help in codifying this \textit{Author's Guide}
and the \textbf{.cls} and \textbf{.tex} files that it describes.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{elq}  % elq.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
% That's all folks!
\end{document}
