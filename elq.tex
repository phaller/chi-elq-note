% THIS IS SIGPROC-SP.TEX - VERSION 3.1
% WORKS WITH V3.2SP OF ACM_PROC_ARTICLE-SP.CLS
% APRIL 2009
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.2SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.2SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@hq.acm.org
%
% For tracking purposes - this is V3.1SP - APRIL 2009

\documentclass{acm_proc_article-sp}

\usepackage{url}
\usepackage{listings}
\lstset{
  basicstyle=\scriptsize
}

\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\elq}{ELQ}

\begin{document}

\title{Allowing Responsive Web Modules}
\subtitle{}
%
% You need the command \numberofauthors to handle the 'placement
% and alignment' of the authors beneath the title.
%
% For aesthetic reasons, we recommend 'three authors at a time'
% i.e. three 'name/affiliation blocks' be placed beneath the title.
%
% NOTE: You are NOT restricted in how many 'rows' of
% "name/affiliations" may appear. We just ask that you restrict
% the number of 'columns' to three.
%
% Because of the available 'opening page real-estate'
% we ask you to refrain from putting more than six authors
% (two rows with three columns) beneath the article title.
% More than six makes the first-page appear very cluttered indeed.
%
% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.
% Add names, affiliations, addresses for
% the seventh etc. author(s) as the argument for the
% \additionalauthors command.
% These 'additional authors' will be output/set for you
% without further effort on your part as the last section in
% the body of your article BEFORE References or any Appendices.

\numberofauthors{3} %  in this sample file, there are a *total*
% of EIGHT authors. SIX appear on the 'first-page' (for formatting
% reasons) and the remaining two appear in the \additionalauthors section.
%
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor
  Ben Trovato\\
  \affaddr{Institute for Clarity in Documentation}\\
  \affaddr{1932 Wallamaloo Lane}\\
  \affaddr{Wallamaloo, New Zealand}\\
  \email{trovato@corporation.com}
% 2nd. author
\alignauthor
  G.K.M. Tobin\\
  \affaddr{Institute for Clarity in Documentation}\\
  \affaddr{P.O. Box 1212}\\
  \affaddr{Dublin, Ohio 43017-6221}\\
  \email{webmaster@marysville-ohio.com}
% 3rd. author
\alignauthor
  Lars Th{\o}rv{\"a}ld\\
  \affaddr{The Th{\o}rv{\"a}ld Group}\\
  \affaddr{1 Th{\o}rv{\"a}ld Circle}\\
  \affaddr{Hekla, Iceland}\\
  \email{larst@affiliation.org}
}

\date{10 October 2015}
% Just remember to make sure that the TOTAL number of authors
% is the number that will appear on the first page PLUS the
% number that will appear in the \additionalauthors section.

\maketitle
\begin{abstract}

\end{abstract}

% A category with the (minimum) three required fields
\category{H.4}{Information Systems Applications}{Miscellaneous}
%A category including the fourth, optional field follows...
\category{D.2.8}{Software Engineering}{Metrics}[complexity measures, performance measures]

\terms{Theory}

\keywords{ACM proceedings, \LaTeX, text tagging} % NOT required for Proceedings

\section{Introduction}
  % \begin{itemize}
  %   \item Why modules? Reusability (even across applications), reduced code complexity.
  %   \item Why responsive design?
  %   \item Responsive Modules of today need to be context aware (thus, not very reusable [they only work in a specific layout]).
  %   \item What do we want and why? Modules that are responsive relative to its outer frame.
  % \end{itemize}

  Responsive Web Design (RWD) is an approach to make an application respond to the viewport size and device characteristics.
  This is currently achieved by using CSS media queries that are designed to conditionally design content by the media, such as using serif fonts when printed and sans-serif when viewed on a screen.

  In order to reduce complexity and enable reusability applications are typically composed of modules, i.e., interchangeable and independent parts that have a single and well-defined responsibility \cite{parnas1972criteria}.
  In order for a module to be reusable it must not assume in which context it is being used.

  In this paper we focus on the presentation layer of web applications.
  As it stands, using media queries to make the presentation layer responsive precludes modularity.
  The problem is that there is no way to make a module responsive without it being context-aware, due to media queries only being able to target the viewport.
  Thus, a responsive module using media queries is layout dependent and has therefore limited reusability.
  Therefore, media queries can only be used for RWD of non-modular static applications.
  In a world where no better solution than media queries exists for RWD, changing the layout of a responsive application becomes a cumbersome task.

  \subsection{The Problem Exemplified}
    % \begin{itemize}
    %   \item MQ is not the solution to RWD. (MQ was not designed for RWD as the feature was released long before RWD)
    %   \item All elements adapt their inner design by the viewport width.
    %   \item Menu Example shows how MQ are broken.
    %   \item Limitations of MQ regarding font-size (em).
    % \end{itemize}
    
    Imagine an application that displays the current weather of various cities as widgets, by using a weather widget module.
    The module should be responsive, so that more information such as a temperature graph over time is displayed when the widget is big.
    When the widget is small it should only display the current temperature.
    Users should also be able to add, remove and resize widgets.

    Such application cannot be built with media queries, since the widgets can have varying sizes independent of the viewport (e.g., the width of one widget is 30\% while another is 40\%).
    To overcome this problem we must change the application so that widgets always have the same sizes.
    This implies that the size of the module and the media query breakpoints are coupled/intertwined, i.e. they are proportional to each other.
    % If we also assume that all widgets always have a fixed percentage, for example 25\% of the viewport width, it is possible to make the module responsive by using media queries.
    The problem now is that we have removed the reusability of the weather module, since it requires the specific width that is correctly proportional to the media query breakpoints. 
%    The problem now is that we have removed the reusability of the weather module, since it may only be used in applications that grant it 25\% of the viewport width.

    Imagine a company working on a big application that uses media queries for responsiveness (i.e., each responsive module assumes to have a specific percentage of the viewport size).
    The ability to change is desired by both developers and stakeholders, but is limited by this responsive approach.
    The requirement of changing a menu from being a horizontal top menu to being a vertical side menu implies that all responsive modules break since the assumed proportionality of each module is changed.
    Even worse, if the menu is also supposed to hide on user input the responsiveness of the module breaks since the layout changes dynamically.
    The latter requirement is impossible to satisfy without element queries.

    Additionally, it is popular to define breakpoints relative to the font size.
    Media queries can only target the font size of the document root, limiting the functionality drastically.
    With element queries, breakpoints may be defined relative to the font size of the targeted element.

    As we can see, even with limited requirements there still are significant flaws with using media queries for responsive modules.

    \label{sec:reqs}
    \subsection{Requirements}
      % \begin{itemize}
      %   \item Parents should decide the layout of their children, and the children should adapt their inner design accordingly.
      %   \item Valid language syntaxes (HTML, CSS, JS).
      % \end{itemize}

      The desired behavior of a responsive module is having its inner design responding to the size of \emph{its container} instead of the viewport.
      Only then is a responsive module independent of its layout context.
      Realizing responsive modules requires CSS rules that are conditional upon \emph{elements}, instead of the global viewport.

      \begin{itemize}
        \item 
          A solution must provide a possibility for an element to change depending on the properties of the parent element.
          Elements should automatically respond to changes of the parent size so that the correct design can be presented for each size.
        \item
          A solution must conform to the syntax of HTML, CSS, and JavaScript so that the compatability of tools, libraries and existing projects is retained.
        \item
          A solution must have adequate performance for large applications that make heavy use of responsive modules.
        \item Extensibility
        \item Composability
      \end{itemize}

    \subsection{Approach}
      In this paper we extend the concept of RWD to also include responsive modules.
      The W3C has discussed such a feature under the name of \emph{element queries} given its analogy to media queries.
      This paper presents a novel implementation of element queries in JavaScript named \elq{}, and discusses the new possibilities of GUI design that our implementation enables.

      Our approach is implemented as a client side library to be included in applications.
      One could argue that a solution does not need to be executed on the client side, but instead generate media queries on the server side for all modules with respect to the current application layout.
      However, this is insufficient due to the modules then being limited to applications with static layouts.
      Also, the generated media queries would not be able to respond to the user changing properties of elements such as layout and font size.

    \subsection{Contributions}
      This paper makes the following contributions:
      \begin{itemize}
        \item A new design that enables responsive modules while conforming to the syntax of HTML, CSS, and JavaScript.
        \item
          % encapsulation of CSS based styling of elements.
          Our approach is the first to enable nested elements that are responsive in a modular way, i.e., styling required for RWD is fully encapsulated in the module.
          As a side effect, responsive modules may also be arbitrarily styled with CSS independently of their context.
          % An approach that enables encapsulated styling of modules crucial for element queries, such as .
          % As a result, responsive modules using \elq{} may also be nested.
        \item
          An extensible library architecture that enables plugins to significantly extend the behavior of the library.
          This makes it possible to create plugins in order to ease integration of \elq{} into existing modules or libraries.
        \item
          A new implementation technique that offers substantially higher performance than previous approaches.
          Our technique batch processes DOM operations so that layout thrashing (i.e., forcing the layout engine to perform multiple independent layouts) is avoided.
      \end{itemize}

    The rest of the paper is organized as follows:


\section{Background}
  \begin{itemize}
    \item Explain media queries really short (simple example). Maybe explain some terminology.
  \end{itemize}

  Media queries and element queries are similar in the sense that they both enable developers to define conditional style rules that are applied by specified criteria.
  The main difference is the type of criteria that can be used; in media queries device, document, and media criteria are used, while element criteria are used in element queries.
  It can somewhat simplified be described as that media queries target the document root and up (i.e., the viewport, browser, OS, device, input mechanisms, etc.) while element queries target the document root and down (i.e., elements of the document).


\section{Overview of \elq{}}
  To enable element queries today, we have developed a novel JavaScript implementation named \elq{}.
  Our implementation satisfied all requirements given in~\ref{sec:reqs}.
  The library have been designed to conform to the standards and specifications of the web languages while providing the features required of building advanced constellations of responsive modules.
  The novelty lies in having significantly improved performance by batch processing DOM operations, and providing an API that enables nesting of modules.
  \elq{} also has excellent browser compatability as it supports Internet Explorer 8 and upwards.

  \elq{} is designed to be plugin-based for increased flexibility and extensibility.
  By providing a good library foundation and plugins it is up to developers to choose the right plugins for each project.
  In addition, by letting the plugins satisfy the requirements it is easy to extend the library with new plugins when new requirements arise.

  \subsection{The API}
    As CSS 3 does not support custom at-rules/selectors, responsive elements are annotated in HTML by element attributes.
    The main idea is to annotate elements with breakpoints of interest so that children can be conditionally styled in CSS by targeting the different breakpoint states.
    In this example, we will use the \code{elq-breakpoints} plugin that observers the element in order to automatically update the breakpoint classes.
    Although not written in the examples, the library also supports attributes defined with the \code{data-} prefix to conform to the HTML standard.

    In listing~\ref{code:elq-breakpoints-example} we see an element that has annotated two breakpoints at 300 and 500 pixels.

    \begin{lstlisting}[gobble=6,caption={},captionpos=b,label={code:elq-breakpoints-example}]]
      <div class="foo" elq elq-breakpoints
        elq-breakpoints-widths="300 500">
        
        <p>When in doubt, mumble.</p>
      </div>
    \end{lstlisting}

    When \elq{} has processed the element, it will always have two classes, one for each breakpoint, that tells if the size of the element is greater or lesser than each breakpoint.
    For instance, if the element is 400 pixels wide, the element has the two classes \code{elq-min-width-300px} and \code{elq-max-width-500}.
    Similarly, if the element is 200 pixels wide the element the classes are instead \code{elq-max-width-300px} and \code{elq-max-width-500}.
    So for each breakpoint only the min/max part changes.
    It may seem alien that the classes describe that the width of the element is both maximum 300 and 500 pixels.
    This is because we have taken a user-centric approach, so that when using the classes in CSS the API is similar to element queries.
    However, developers are free to change this API at will as \elq{} is plugin-based.

    Now that we have defined the breakpoints of the element, we can conditionally style it by using the classes.
    See listing~\ref{code:elq-breakpoints-example-css} for an example of how the classes can be used.

    \begin{lstlisting}[gobble=6,caption={},captionpos=b,label={code:elq-breakpoints-example-css}]]
      .foo.elq-min-width-300px.elq-max-width-500px {
        background-color: green;
      }

      .foo.elq-min-width-500px {
        background-color: blue;
      }

      .foo.elq-max-width-500px p {
        color: white;
      }
    \end{lstlisting}

    \subsubsection{Nested modules}
      This API is sufficient for applications that do not need nested breakpoint elements, and similar features is provided by related libraries.
      However, using such API in responsive modules still limits the reusability since the modules then may not exist in an outer responsive context.
      Also, it is customary to compose large/complex modules by smaller modules that may also need to be responsive \cite{parnas1972criteria}.

      The reason this API is not sufficient for nested modules is because there is no way to limit the CSS matching search of the selectors.
      The selector of the last example given in listing~\ref{code:elq-breakpoints-example-css} specifies that all paragraph elements should have white text if \emph{any} ancestor breakpoints element is above 500 pixels wide.
      Since the ancestor selector may match elements outside of the module, such selectors are dangerous to use in the context of responsive modules.
      The problem may be somewhat reduced by more specific selectors and such, but it cannot be fully solved for arbitrary styling.

      To solve this problem, we provide a plugin that let us define elements to ``mirror'' the breakpoints classes of the nearest ancestor breakpoints element.
      Then, the conditional style of the mirror element may be written as a combinatory selector that is relative to the nearest ancestor breakpoints element.
      See listing~\ref{code:elq-mirror-example} for example markup of the mirror plugin to enable nested modules.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:elq-mirror-example}]]
        <div class="foo" elq elq-breakpoints
          elq-breakpoints-widths="300 500">
          
          <div class="foo" elq elq-breakpoints
            elq-breakpoints-widths="300 500">

            <p elq elq-mirror>...</p>
          </div>

          <p elq elq-mirror>...</p>
        </div>
      \end{lstlisting}

      As the paragraph elements are mirroring the nearest \code{.foo} ancestor, we can now write CSS as shown in listing~\ref{code:elq-mirror-example-css}.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:elq-mirror-example-css}]]
        .foo {
          /* So that the nested module 
             behaves differently */
          width: 50%;
        }

        .foo p.elq-max-width-500px {
          color: white;
        }
      \end{lstlisting}

      Since we in the previous examples have annotated elements manually, the power and flexibility of the API have not been properly displayed.
      Only when combined with JavaScript, things get more interesting.
    \subsubsection{A high-level API}
      To further prove the potential of \elq{}, we have created a plugin that enables a high-level API for responsive modules.
      The API enables developers to use resposnive grids and utility classes very similar to the ones defined by the CSS Bootstrap framework.
      See listing \ref{code:elq-grid-example} for an example grid that uses the Bootstrap API.
      The grid is defined to be single columned for small viewports, triple columned for medium viewports, and double columned for large viewports.
      It should be noted that the last column is hidden for large viewports.

      \begin{lstlisting}[gobble=8,caption={},captionpos=b,label={code:elq-grid-example}]]
        <div class="container">
          <div class="row">
            <div class="col-md-4 col-lg-6">
              ...
            </div>
            <div class="col-md-4" col-lg-6>
              ...
            </div>
            <div class="col-md-4 hidden-lg-up">
              ...
            </div>
          </div>
        </div>
      \end{lstlisting}
      
      Since this API uses media queries, there only exists a fixed set of breakpoints that can be used to determine when the grid should change layout.
      The column classes defines the behaviour of a the grid, and has the syntax \code{col-[breakpoint]-[size]}.
      Developers may choose which breakpoint to be used by the \code{sm, md, lg} units of a column class and the size may be between 1 and 12.

\section{Extensions via plugins}
  \begin{itemize}
    \item Overall architecture
    \item Plugin API
    \item Example plugin
  \end{itemize}

\section{Implementation}
  Batching.
  Resize listening.

\section{Empirical evaluation}
  \subsection{Performance}
  \subsection{Case studies}
    Plugins makes it easy to integrate.



\section{Discussion}
  \begin{itemize}
    \item Performance, APIs, Features.
    \item The mirror functionality of \elq{} makes it uniquely suitable for nested modules.
  \end{itemize}

  \subsection{Limitations}
    (Drawbacks)
    No good alternative.
    Mention RICG (perhaps standard that solves the issue in the future).


  \subsection{Standardization}
    It is stated on the W3C's www-style mailing list \cite{w3c_eq_mail} by Zbarsky of Mozilla, Atkins of Google and Sprehn of Google that element queries are infeasible to implement without restricting them.
    By limiting element queries to specially separated container elements that can only be queried by child elements, many of the problems are resolved \cite{ricg_irc_log,ricg_issue_viewport}.
    Therefore, the Responsive Issues Community Group (RICG) is currently investigating the possibility of standardizing \emph{container} queries.

    Unfortunately, even such limited container queries requires significant effort to implement \cite{ricg_issue_viewport}.
    Atkins argues that a correct and full implementation is unlikely to be implemented, and therefore it might be wiser to pursue sub-standards that aids third-party solutions instead.
   
    In the future, we hope that Elq may use the aiding sub-standards pushed by RICG, to achieve greater flexibility and performance.

    We want RICG to standardize the following: bla bla bla

\section{Related Work}
  

\section{Conclusions}
  \begin{itemize}
    \item Production ready.
    \item Probably no standard (or not in a long time).
  \end{itemize}

%\end{document}  % This is where a 'short' article might terminate

%ACKNOWLEDGMENTS are optional
\section{Acknowledgments}
This section is optional; it is a location for you
to acknowledge grants, funding, editing assistance and
what have you.  In the present case, for example, the
authors would like to thank Gerald Murray of ACM for
his help in codifying this \textit{Author's Guide}
and the \textbf{.cls} and \textbf{.tex} files that it describes.

%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{elq}  % elq.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns
% That's all folks!
\end{document}
